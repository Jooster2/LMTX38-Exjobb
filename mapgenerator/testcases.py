"""
Testing functions for the Map Generator are here. They are run according to command line 
arguments. All tests run for a specified number of iterations, but also have a fairly sane
standard argument.
"""

from contextlib import contextmanager
import os, sys, pydoc
from time import time

from mapgen import create_grid, create_endpoints
from cell import Cell
from directions import Side
from algorithm import generate_maze, find_solution
from path_creators import cells_remaining


def grid_complete_test(iterations=500, algo="PTF"):
    """
    ARGS: iterations(=500), algo(="PTF")
    Test that the algorithm specified has created a maze in which
    all cells are connected, and thus reachable.
    """
    try:
        iterations = int(iterations)
        algo = str(algo)
    except:
        print("Error, grid complete test, wrong argument type")
        return
    print("Starting grid complete test, running {} iterations, {} algorithm".format(iterations, algo))
    start_time = time()
    x = 8
    y = 8
    i = 0
    while i <= iterations:
        print("Iteration:", i)
        with suppress_stdout():
            grid, outer_walled = create_grid(x,y)
            s_pt, f_pt = create_endpoints(outer_walled)
            generate_maze(grid, s_pt, f_pt, algo)
        assert cells_remaining(grid) == 0
        i += 1
    print("Grid complete test finished {} iterations successfully in {} seconds".format(iterations, time() - start_time))



def outer_walls_test(iterations=50000):
    """
    ARGS: iterations(=50000)
    Test that the start point and finish point have been created
    on the sides (have at least one outer wall).
    """
    try:
        iterations = int(iterations)
    except:
        print("Error, outer walls test, wrong argument type")
        return
    print("Starting outer walls test, running {} iterations".format(iterations,))
    start_time = time()
    x = 5
    y = 5
    i = 0
    while i <= iterations:
        if i % 10000 == 0:
            print("Iteration: {}".format(i,)) 
        grid, outer_walled = create_grid(x,y)
        s_pt, f_pt = create_endpoints(outer_walled)
        assert s_pt.has_outer_walls() == True, "Start has no outer walls"
        assert f_pt.has_outer_walls() == True, "Finish has no outer walls"
        i += 1
    print("Outer walls test finished {} iterations successfully in {} seconds".format(iterations, time() - start_time))

def solver_test(iterations=300, algo="DFS", expand="False"):
    """
    ARGS: iterations(=300), algo(="DFS"), expand(="False")
    Test that the maze generated by specified algorithm is 
    solvable. The expand parameter says to create larger and larger
    mazes (default start size is 8x8).
    Also calculates and prints the number of steps in the shortest
    solution found.
    """
    min_path = 100
    try:
        iterations = int(iterations)
        algo = str(algo).upper()
        expand = str(expand).lower()
    except:
        print("Error, solver test, wrong argument type")
        return
    print("Starting solver test, running {} iterations, {} algorithm".format(iterations, algo))
    start_time = time()
    x = 8
    y = 8
    i = 0
    size_change = True
    while i <= iterations:
        if size_change:
            print("Size is currently: {}x{}".format(x, y))
            size_change = False
        print("Iteration: {}".format(i,)) 
        with suppress_stdout():
            grid, outer_walled = create_grid(x,y)
            s_pt, f_pt = create_endpoints(outer_walled)
            generate_maze(grid, s_pt, f_pt, algo)
            solution = find_solution(s_pt)
            min_path = min(min_path, len(solution))
        assert solution != False, "Solution was False"
        assert solution[0] is s_pt, "Solution has faulty starting position"
        assert solution[-1] is f_pt, "Solution has faulty finish position"
        i += 1
        if i % 10 == 0 and expand == "true":
            x += 1
            size_change = True
        if i % 15 == 0 and expand == "true":
            y += 1
            size_change = True
    print("Find solution test finished {} iterations successfully in {} seconds".format(iterations, time() - start_time))
    print("Shortest solution created in all iterations:", min_path)

@contextmanager
def suppress_stdout():
    """
    Used to suppress any unwanted output to console. This is used by the tests to stop any
    called method from cluttering the console, thus ensuring only test-relevant data is
    outputted.
    """
    with open(os.devnull, 'w') as devnull:
        old_stdout = sys.stdout
        sys.stdout = devnull
        try:
            yield
        finally:
            sys.stdout = old_stdout

if __name__ == '__main__':
    """
    Add tests to available_tests as they are constructed. This allows calling from the
    command line. Example:
        $ python testcases.py sot 5500 PTF False
        will call solver test for 5500 iterations, with path to finish algorithm, 
        and no enlargening maze

    """

    # Dictionary of all available tests
    available_tests = {"owt": outer_walls_test,
                       "sot": solver_test,
                       "gct": grid_complete_test}

    # Default behaviour if no cmd-line arguments were specified
    if len(sys.argv) == 1:
        print("No arguments specified, running default tests...")
        outer_walls_test()
        solver_test()
        grid_complete_test()
        print("Default tests finished, exiting...")
        sys.exit()

    for idx,x in enumerate(sys.argv):
        # First element in sys.argv is always the name of the file, skip it
        if x == "testcases.py":
            continue
        if x in available_tests.keys():
            args = []
            # Any data found between function name x and the next are used as arguments
            for i in range(idx+1, len(sys.argv)):
                if sys.argv[i] not in available_tests.keys():
                    args.append(sys.argv[i])
                else:
                    break
            # Call function with name x, and pass the arguments in args
            available_tests[x](*args)
            break

        elif x in ["--help", "-h"]:
            print("Usage: testcases [TEST]... [ARGS]...")
            print("Available TESTS:")
            for a in available_tests.keys():
                print(a, available_tests[a].__doc__)
        else:
            print("testcases: invalid option --", x)
            print("try 'testcases --help' for more information")




