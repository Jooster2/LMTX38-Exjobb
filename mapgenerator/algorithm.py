from cell import Cell
from directions import Side
from path_creators import depth_first, path_to_finish
from visit_complete import visit_complete
from branch import Branch

def generate_maze(grid, s_pt, f_pt, algorithm="PTF"):
    """
    Generate a maze according the the specified algorithm. 
    """
    if algorithm == "PTF":
        res = path_to_finish(grid, s_pt, f_pt)
        branch = visit_complete(grid, res)
        print("\nAlgorithm finished correctly")
        return branch


def find_solution(current_cell, previous_cell=None):
    """
    Recursive solution finder to the maze generated by the
    algorithm above. Call with the start-point to get a solution.
    Return False if it is unsolvable (should not happen).
    """
    if current_cell.is_finish:
        # Algorithm ends here.
        return [current_cell]
    elif len(current_cell.get_walls(False)) < 2 and \
            current_cell.is_start == False and \
            current_cell.is_finish == False:
        # A dead end found.
        return []
    else:
        solution = [current_cell]
        for side in current_cell.get_walls(False):
            # Check sides with knocked walls.
            if previous_cell is not \
                    current_cell.get_neighbour(side):
                # Skip checking the cell we came from (avoid inf. looping).
                branch = find_solution(current_cell. \
                        get_neighbour(side), current_cell)
                if branch:
                    solution.extend(branch)
                    return solution
        if len(solution) <= 1:
            return False


