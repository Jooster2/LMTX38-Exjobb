from cell import Side
from cell import Cell



def generate_maze(grid, outer_walled, s_pt, f_pt):
    """Start at s_pt, and knock down walls in a depth-first search.
       Only stop when all cells in the grid have been visited."""
    visited_cells = []
    current_cell = s_pt
    print("Starting algorithm\nNumber of cells remaining: ", end="")
    while cells_remaining(grid):
        print(cells_remaining(grid), end=", ")
        for side in Side.random_all():
            if current_cell.get_neighbour(side).is_not_visited():
                visited_cells.append(current_cell)
                current_cell.knock_wall(side)
                current_cell = current_cell.get_neighbour(side)
                break
            
        # If there were no unvisited cells on any side
        else:
            try:
                # Backtrack one step, and remove cell from solution
                current_cell = visited_cells.pop()
            except IndexError as e:
                print(e)

    print("\nAlgorithm finished correctly")
    
    return grid




def cells_remaining(grid):
    """Return the number of cells in the grid that have all
       four walls intact."""
    number = 0
    for vertical in grid:
        for cell in vertical:
            if cell.is_not_visited():
                number += 1
    return number


def find_solution(current_cell, previous_cell=None):
    """Recursive solution finder to the maze generated by the
       algorithm above. Call with the start-point to get a solution.
       Return False if it is unsolvable (should not happen)."""
    if current_cell.is_finish:
        print("Found finish")
        return [current_cell]
    elif len(current_cell.get_walls(False)) < 2 and \
            current_cell.is_start == False and \
            current_cell.is_finish == False:
        print("False path")
        return []
    else:
        solution = [current_cell]
        for side in current_cell.get_walls(False):
            if previous_cell is not current_cell.get_neighbour(side):
                print("Branching to {}".format(side.name,))
                branch = find_solution(current_cell.get_neighbour(side), \
                        current_cell)
                if branch:
                    #print("Branch is true, extending solution")
                    solution.extend(branch)
                    return solution
        if len(solution) <= 1:
            return False



