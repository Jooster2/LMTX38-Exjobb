from cell import Cell
from directions import Side
from path_creators import depth_first, path_to_finish
from dfs_alt import permeate_grid
from branch import Branch

def generate_maze(grid, s_pt, f_pt, algorithm="DFS"):
    """
    Generate a maze according the the specified algorithm. 
    """
    if algorithm == "DFS":
        depth_first(grid, s_pt, [])
        print("\nAlgorithm finished correctly")
    elif algorithm == "PTF":
        res = path_to_finish(grid, s_pt, f_pt)
        branches = depth_first(grid, s_pt, res)
        print("\nAlgorithm finished correctly")
        return branches
    elif algorithm == "PG":
        res = path_to_finish(grid, s_pt, f_pt)
        branch = permeate_grid(grid, res)
        print("\nAlgorithm finished correctly")
        return branch



def find_solution(current_cell, previous_cell=None):
    """
    Recursive solution finder to the maze generated by the
    algorithm above. Call with the start-point to get a solution.
    Return False if it is unsolvable (should not happen).
    """
    if current_cell.is_finish:
        print("Found finish")
        return [current_cell]
    elif len(current_cell.get_walls(False)) < 2 and \
            current_cell.is_start == False and \
            current_cell.is_finish == False:
        print("False path")
        return []
    else:
        solution = [current_cell]
        for side in current_cell.get_walls(False):
            if previous_cell is not current_cell.get_neighbour(side):
                print("Branching to {}".format(side.name,))
                branch = find_solution(current_cell.get_neighbour(side), \
                        current_cell)
                if branch:
                    #print("Branch is true, extending solution")
                    solution.extend(branch)
                    return solution
        if len(solution) <= 1:
            return False


