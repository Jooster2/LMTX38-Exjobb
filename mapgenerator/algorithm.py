from cell import Side
from cell import Cell



def generate_maze(grid, outer_walled, s_pt, f_pt):
    """Start at s_pt, and knock down walls in a depth-first search.
       Only stop when all cells in the grid have been visited.
       Currently has a built-in solution finder, that doesn't work
       properly. Should be removed and replaced with a recursive
       solution-finder (see below)."""
    visited_cells = []
    solution = []
    solution.append(s_pt)
    current_cell = s_pt
    print("Starting algorithm\nNumber of cells remaining: ", end="")
    while cells_remaining(grid):
        print(cells_remaining(grid), end=", ")
        for side in Side.random_all():
            if current_cell.get_neighbour(side).is_not_visited():
                visited_cells.append(current_cell)
                if current_cell.is_finish:
                    print("\nCurrent cell is finish")
                if solution[-1].is_finish == False:
                    solution.append(current_cell)
                    if current_cell.is_finish:
                        print("Appended finish to solution")

                current_cell.knock_wall(side)
                current_cell = current_cell.get_neighbour(side)
                if cells_remaining(grid) == 0 and \
                  current_cell.is_finish:
                    solution.append(current_cell)
                    print("Adding finish 'manually'")
                break
            
        # If there were no unvisited cells on any side
        else:
            try:
                # Backtrack one step, and remove cell from solution
                current_cell = visited_cells.pop()
                if solution[-1].is_finish == False:
                    solution.pop()
            except IndexError as e:
                print(e)


    # Debugging
    try:
        assert solution[-1] is f_pt
    except AssertionError as e:
        print(e)
        for cell in solution:
            print(cell)
        print("------------------------------------")
        print("Last one should be: \n{}".format(f_pt),)
        raise AssertionError("Bad solution created, exiting algorithm")

    # Clean up any multiples of the starting point
    while solution[1] is s_pt:
        solution.pop(0)
    print("\nAlgorithm finished correctly")
    
    return [grid, solution]




def cells_remaining(grid):
    """Return the number of cells in the grid that have all
       four walls intact."""
    number = 0
    for vertical in grid:
        for cell in vertical:
            if cell.is_not_visited():
                number += 1
    return number


def find_solution(current_cell, solution=[]):
    """Recursive solution finder to the maze generated by the
       algorithm above. Call with the start-point to get a solution.
       Return False if it is unsolvable (should not happen)."""

